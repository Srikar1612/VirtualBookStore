package com.virtualbookstore.bookstoreapp.Services;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.virtualbookstore.bookstoreapp.Entities.Book;
import com.virtualbookstore.bookstoreapp.Entities.CartItem;
import com.virtualbookstore.bookstoreapp.Entities.Order;
import com.virtualbookstore.bookstoreapp.Entities.OrderItem;
import com.virtualbookstore.bookstoreapp.Entities.User;
import com.virtualbookstore.bookstoreapp.enums.OrderStatus;
import com.virtualbookstore.bookstoreapp.repo.BookRepository;
import com.virtualbookstore.bookstoreapp.repo.CartItemRepository;
import com.virtualbookstore.bookstoreapp.repo.OrderItemRepository;
import com.virtualbookstore.bookstoreapp.repo.OrderRepository;
import com.virtualbookstore.bookstoreapp.repo.UserRepository;

@Service
public class OrderService {
	
	private final OrderRepository orderRepository;
	private final CartItemRepository cartItemRepository;
	private final BookRepository bookRepository;
	private final UserRepository userRepository;
	private final OrderItemRepository orderItemRepository;
	
	public OrderService(OrderRepository orderRepository, CartItemRepository cartItemRepository, BookRepository bookRepository, UserRepository userRepository, OrderItemRepository orderItemRepository) {
		
		this.orderRepository=orderRepository;
		this.cartItemRepository=cartItemRepository;
		this.bookRepository=bookRepository;
		this.userRepository=userRepository;
		this.orderItemRepository=orderItemRepository;
		
	}

	@Transactional
	public Order createOrderFromCart(Long userId) {
		
		User user;
			
		Optional<User> optionalUser = userRepository.findById(userId);
			
		if(optionalUser.isPresent()) {
				
			user=optionalUser.get();
				
		} else {
				
			throw new RuntimeException("User not found");
				
		}
			
		List<CartItem> cartItems=cartItemRepository.findByUserId(userId);
		List<OrderItem> orderItems=new ArrayList<>();
		double orderPrice=0.0;
		
		if(cartItems.isEmpty())
			throw new RuntimeException("Cart is Empty");
		
		for(CartItem cartItem: cartItems) {
			
			Long bookId = cartItem.getBook().getId();
			Book book = bookRepository.findById(bookId).orElseThrow(() -> new RuntimeException("Book not found"));
			int quantity = cartItem.getQuantity();
			int stock=book.getStock();
			double price=book.getPrice();
			
			if(quantity>stock) {
				throw new RuntimeException("Insufficient stock for Book with Id: "+ book.getId());
			}
			
			book.setStock(stock-quantity);
			bookRepository.save(book);
			
			OrderItem orderItem = OrderItem.builder()
				.user(user)
				.book(book)
				.quantity(quantity)
				.priceAtPurchase(price)
				.quantity(quantity)
				.build();
			orderItems.add(orderItem);
			orderPrice+=price*quantity;
			
		}
		
		Order order= Order.builder()
						.orderItem(orderItems)
						.status(OrderStatus.Placed)
						.totalPrice(orderPrice)
						.user(user)
						.build();
		
		Order savedOrder = orderRepository.save(order);
		
		for(OrderItem item: orderItems ) {
			
			item.setOrder(savedOrder);
			orderItemRepository.save(item);
			
		}
		
		cartItemRepository.deleteAll(cartItems);
		
		return savedOrder;
		
	}

	public List<Order> getAllOrders(Long userId) {
		// TODO Auto-generated method stub
		return orderRepository.findByUserId(userId);
		
	}

	public Order getOrder(Long orderId, Long userId) {
		
		Order order= orderRepository.findById(orderId).orElseThrow(()->new RuntimeException("Order not found"));
		Long orderUserId=order.getUser().getId();
		
		if(orderUserId!=userId)
			throw new RuntimeException("This order dos not belong to you");
		else {
			
			return order;
			
		}
	}

	@Transactional
	public Order cancelOrder(Long orderId, Long userId) throws IllegalAccessException {
		
		Order order=orderRepository.findById(orderId).orElseThrow(() -> new RuntimeException("Order not found"));
		Long orderUserId = order.getUser().getId();
		
		if(orderUserId!=userId)
			throw new IllegalAccessException();
		
		if(order.getStatus()!=OrderStatus.Processing && order.getStatus()!=OrderStatus.Placed) {
			
			throw new RuntimeException("Order cannot be cancelled when "+order.getStatus());
			
		}
		
		for(OrderItem orderItem: order.getOrderItem()) {
			
			Long bookId=orderItem.getBook().getId();
			Book book=bookRepository.findById(bookId).orElseThrow(()-> new RuntimeException("book not found with id: "+bookId));
			
			book.setStock(book.getStock()+orderItem.getQuantity());
			bookRepository.save(book);
			
		}
		
		order.setStatus(OrderStatus.Cancelled);
		return orderRepository.save(order);
		
	}
	

}
